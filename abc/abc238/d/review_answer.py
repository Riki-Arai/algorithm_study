# 2025/11/12に追記
# ビット演算ではx+y=2×(xANDy)+(xXORy)が成立する
    # ちなみに2倍しているのは繰り上がりが関係している
    # and条件では1の位置が一致したものを残しているだけになってしまい、繰上げに対応できていない
    # そこで左へ1シフトに対応している2倍を施すことで繰上げ、繰上げが必要な部分に関する計算が完了する
    #　繰り上がりが不要な部分はXORに対応しているので、その箇所をXORYで抽出して、最後に合算することでx+yに一致する
# xANDy=a、xORy=differに置き換えることができる
# これらを矛盾しないためにはa&differ=0でなければならない(ANDは1であるもの同士を残し、ORは1であるもの同士は残さないので、これらの&条件は0になる)
T = int(input())
for _ in range(T):
    a, s = map(int, input().split())
    ans = "No"
    # x and y = aを満たすということはaをbitに変換した際の1となっている位置が、xとyにおいてもその位置で1でなければいけない
    # よってa=5であれば101となるが、xとyは101である必要がある。
    # 従って少なくとも101でないといけないことからx + y >= 2*aが成立（>=となっているのはx=101、y=111といったケースもあるため）
    if 2 * a <= s:
        # 1つ目のand条件を満たした時に2つ目の条件を満たすためにはx+yでは足りない分(differ)を足さないといけない
        differ = s - 2 * a
        # bit換算した時にdifferとaの1の位置が同じである場合だと、x+yにdifferを足すことで1の位置が0に反転してしまうので成立しない
        # よってdiffer%a == 0である必要があ。
        # x=101、y=101だったときに、仮にyにdiffer=001を足すとy=110となってしまうのでx&y=5が成立しない。（xにdifferを足しても同様）
        if (differ & a) == 0:
            ans = "Yes"

    print(ans)
